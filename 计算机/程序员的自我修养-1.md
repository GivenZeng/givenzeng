问：
- 操作系统是怎么加载程序的？
- 编译器是怎么将不同的代码合并到一个可执行文件的？
- 程序是从main开始的吗？在运行main之前发生了什么，之后又发生了什么
- ELF文件里面存的是什么？
- 怎么编写一个不需要操作系统但可以直接在硬件上跑的程序？
- 句柄到底是什么东西？

如果你想了解以上问题，那么我觉得可以阅下这本书。书中的源码可从[github](https://github.com/xprayc/link-load-library-code)获取。
# 编译过程

我们都知道，编译器的工作过程大致分为以下几个阶段：
## 预编译：
  处理源代码文件的中的 ”#“开始的指令，如include、define等，本质工作就是文本替换，输出的仍旧是一个文本文件。主要工作如下：
  - 将所有define删除，并且展开宏定义
  - 处理所有条件预编译指令，如#if、#ifdef等
  - 处理#include，将被包含的文件插入到该预编译指令的位置。（递归进行，因为被包含的文件还可能包含其他文件）
  - 删除所有注释
  - 添加行号和文件名标志，便于产生调试用的行号信息，及编译时产生错误或警告时能显示行号
  - 保留所有#pragma编译器指令

```sh
$cat hello.c
#include <stdio.h>

int main(){
	printf("Hello world\n");
	return 0;
}
# 简单的hello world，也会输出一个近千行的文本文件hello.i
$gcc -E hello.c -o hello.i
```

## 编译
这一步是把处理好的文件进行词法、语法、语义分析，及优化生成相应的汇编代码，产出s文件（文本文件）

```sh
# 本质上，gcc调用的是一个cc1的程序来生成s文件，其他阶段也类似
# gcc只是对多个后台程序的包装，它会根据不同的参数调用预编译器cc1、汇编器as、链接器ld
$gcc -S hello.i -o hello.s

$cat hello.s
	.file	"hello.c"
	.section	.rodata
.LC0:
	.string	"Hello world"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$.LC0, %edi
	call	puts
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)"
	.section	.note.GNU-stack,"",@progbits
```


## 汇编
将汇编代码转变成机器可以执行的指令，每个汇编语几乎都对应一条机器指令，生成二进制文件（o文件）

```sh
$as hello.s -o hello.o
# or
$gcc -c hello.s -o hello.o
# or
$gcc -c hello.c -o hello.o
```

如果我们直接运行hello.o，会显示如下的错误信息：
```sh
$ chmod a+x hello.o
$ ./hello.o
gcc: 警告：hello.o：未使用链接器输入文件，因为链接尚未完成
```

## 链接
链接器将很多o文件合并起来，输出最终可执行的目标文件

```sh
$ld -static xx.o yy.o ..args... hello.o
```

上面的命令是不完全的，而且在不同机器/环境上，命令、参数也有所不同。但是，一般而言，都用到了很多o文件，并输入了一大堆参数。这些额外的o文件是什么呢？它们的作用是什么？为什么要链接完成才能运行呢？这就是本书的需要介绍的内容了。

我们的hello.c不是一个完整的程序代码，它还引用了stdio.h。这些模块之间的组合，才最终产生了可执行的文件。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使其能够相互衔接。主要工作就是合并o文件的机器代码、分配、调整变量、函数的地址等等。

<p align="center">
<img src="./source/拼图.jpg" alt="链接" width="350"/>
</p>

比如我们的hello.c中，使用了其他模块的printf函数。但是在编译heelo.c的时候，编译器并不知道printf的地址，所以它暂时将这些调用printf的指令的目标地址搁置，等待最后链接的时候由链接器将这些指令的目标地址修正。链接器会在链接的时候，根据你所引用的符号printf，到相应的模块寻找printf的地址，并将指令修正，这就是静态链接的基本过程。地址修正的过程也叫重定位Relocation，每个要被修正的地方叫一个重定位入口。

# 附
- 有个叫lex的程序可以实现词法扫描，他会按照用户之前描述好的规则将输入的字符串分割成一个个记号/token。
- 词法分析器将扫描器产生的token进行词法分析，从而产生词法树。这个过程采用了上下文无关文法。有一个工具叫yaac，可以根据用户给定的语法规则对输入的token序列进行解析，从而构建出一棵语法树。
- 语义分析：
  - 静态语义分析：包含但不限于类型标注、检查
  - 动态语义分析：运行期出现的语义相关问题，如除零等
- 中间代码优化：将语法树转化为中间代码，基于中间代码进行优化（如将2+6直接优化为8、顺序调整）。中间代码和目标代码十分相似，但一般和目标机器、运行环境无关，如不包含数据尺寸、变量地址、寄存器名字等
- 目标代码生成与优化：将中间代码转换为目标机器代码，较为复杂（不同机器有不同的字长、寄存器、整数数据类型、浮点数数据类型等）。选择合适的寻址方式、使用位移代替乘法、删除多余指令、针对流水线、多发射等特性优化...
- 符号代表一个地址，这个地址可以是一段子程序的起始地址，也可以是一个变量的起始地址。
- 每个模块的源文件（如.c）经过编译器编译成目标文件（Object File，扩展名为.o），目标文件和库（如运行时库）链接起来，形成最终的可执行文件。在部分书籍Object File有时也会被称为可重定位目标文件或中间目标文件。