# 事务
事务的定义是：一个事务是一组对数据库中数据操作的集合。无论集合中有多少操作，对于用户来说，只是对数据库状态的一个原子改变。

举个例子来讲解：数据库中有两个用户的银行账户 A:100 元; B:200 元。假设事务是 A 转账 50 元到 B，可以理解为这个事务由两个操作组成：1) A-= 50; 2) B+=50。对于用户来说，数据库对于这个事务只有两个状态：执行事务前的初始状态，即 A:100 元; B:200 元，以及执行事务后的转账成功状态：A:50 元;B:250 元，不会有中间状态，比如钱从 A 已经扣除，却还没转到 B 上:A:50 元; B:200 元。

总之，一个事务是一组对数据库中数据操作的集合。事务，对于数据库系统，具有原子性(atomicity)，一致性(consistency)，隔离性(isolation)，以及持久性(durability)。

# 隔离级别
最简单的方法：给数据库加一个全局的操作锁，在同一时间里只允许一个用户对数据库进行操作，这就保证了隔离性。

这样可以保证隔离性，但也限制了并发性，对数据库的性能产生了极大的影响。并且这个世界并非非黑即白，隔离性也并不是有或者没有。数据库一般会提供多种隔离性的级别，供用户选择：越严格的隔离级别越接近全局锁，越宽松的隔离级别越能提高并发。天下没有免费的午餐，宽松的隔离级别也会随之带来一些问题。


msyql的默认隔离级别是可重复读。

<p align="center">
<img src="./img/隔离级别.png" alt="人性的枷锁.png" style="width:500px"/>
</p>


# 隔离的实现方法
强烈推荐[事务、隔离、并发-顾仲贤](https://www.infoq.cn/article/KyZjpzySYHUYDJa2e1fS)

## 锁
实现事务隔离的最简单方法就是在对任何数据进行读写时，都保证互斥性，即当一个事务在读写数据时，保证其他事务不能对数据进行修改。最常见的实现就是对数据进行加锁(lock)。

很明显，全局锁并发低，因此我们通过细分锁粒度，得到表锁、行锁。

数据被锁后，不能再被其他事务读写，可以通过锁类型（共享锁、独占锁）来提升读并发能力。

常见的db中，用户都是读-写-读乱序，那从事务开始到事务结束，什么时候该加锁，什么时候又该释放锁呢？？随便加锁都可以吗？

### 两段锁机制
不同严格版本的两阶段锁，提供了不同的隔离级别。

## 宽松版
- 获取锁阶段：事务只能不断获取锁，不能释放
- 释放锁阶段：只能逐渐释放锁，并且无权再获取新的锁

### 严格版
宽松版可能导致连锁回滚，因此可以在宽松版的基础上，规定独占锁(X-lock)必须等到事务结束时才释放。

### 更严格
在严格版的基础上，规定所有获得的锁都得等到事务结束时才释放。


不要和两阶段提交(Two-phase commit (2PC))搞混；千万不要和两阶段提交搞混；千万不要和两阶段提交搞混。两阶段提交是针对分布式事务的概念。



## 时间戳/事务id机制
除了锁，还有什么能够实现事务的隔离呢？一个想法是时间戳机制。我们通过统一的数字计数器，给每个事务分发id，这通过一个机器指令即可实现。创建事务的时候必须通过数字计数器得到一个id。对于数据A：
- w(A):表示最近一个写A的事务的id 
- r(A):表示最近一个读A的事务的id

事务Ti，只能读w(a)<=i的数据；只能写r(a)<=i && w(a) =< i 的数据，否则回滚。

时间戳机制保证了有序性，因为读写都会根据事务的时间戳进行比较再回滚。这种机制同时也避免了死锁，虽然有可能导致饥饿(starvation)：某些运气不好的长事务因为不停地失败被回滚然后重试。


## MVTO 多版本时间戳(Multi-Version Timestamp Ordering)
前面的问题可能导致锁的饥饿，并且限制了读的并发。版本控制能够很好地解决这类读写冲突，尤其是长时间的读操作饿死写操作问题。

时间戳和多版本控制结合就形成了多版本时间戳机制。对于每个事务 Ti，系统都会设置相应的事务时间 TS(Ti)。对于每个数据单元 Q，系统会保存一系列的版本数据 Q1，Q2，Q3，… Qn。其中，每个版本 Qx 保存以下信息：
- 当前版本的数据值
- W-TS(Qx): 当 Qx 被某个事务 Ti 创建的时间戳，即 TS(Ti)
- R-TS(Qx): 由于一个版本的数据可以被多个事务读取，这里存储的是最大的事务时间戳：最近一次被某个事务 Tj 读取成功的时间戳，即 TS(Tj)

给定当前事务 Ti 对数据 Q 发起了一个读操作 read(Q)或者写操作 write(Q)。并假定，版本 Qk 是 Q 的所有版本中持有最大的但小于或等于 TS(Ti)的 W-TS 的时间戳。则：
- 如果 Ti 是读操作，则读取成功，返回 Qk 中的值给 Ti。
- 如果 Ti 是写操作，则需要判断，如果 TS(Ti) < R-TS(Qx)，即说明有一个更新的事务已经读取了数据，因此系统判定更新失败，回滚 Ti。如果 TS(Ti) = W-TS(Qx)，系统可以直接将 Ti 的值覆盖 Qk 的原值；如果 TS(Ti) > R-TS(Qx)，则创建一个新的版本 Q。

多版本时间戳机制
- 优点：一个读取数据的事务永远不会失败也不需要等待。在一个读多写少的场景下，相比于先前介绍的两种机制，会有很好的性能提升
- 缺点：就是在读取操作的事务中，也需要更新相应的 R-TS(Qk)，并且读取数据，这就导致可能产生两次磁盘操作，而非只读一次。另外，当写操作发生冲突时，它会要求回滚失败的事务，相比起等待，回滚操作可能更昂贵一些。下面介绍的另一种的实现可以解决这个问题。

## MVCC 多版本两阶段加锁(Multi-Version Two-Phase Locking)
多版本两阶段加锁机制，相比于上文介绍的多版本时间戳机制，是要集多版本控制和两阶段加锁之所长。它会区分对待只读操作的事务和有更新操作的事务。

- 对于只读操作的事务 Ti，数据库系统会把 TS(Ti)赋于当前 TS-Counter 的值，这样 Ti 读取数据就和上面介绍的多版本时间戳一样，会读取到最大的但小于或等于 TS(Ti)的 Q 版本的值。
- 对于有更新操作的事务，如果要读取一个数据，首先，它会获取这个数据的共享锁，并且读取最新版本的数据。当事务需要写数据时，首先要获取数据的独占锁并且创建一个新的版本，并把版本的时间戳设置为无穷大，当这个事务要被提交时，把它锁创建的所有数据的新版本的时间戳设置为 TS-Counter+1，并且同时更新系统的 TS-Ccounter，也变为 TS-Counter+1。

优点：单纯的读事务无需加锁也无需回盘。

总结一下，多版本时间戳机制和多版本两阶段加锁，两者都保证了对于只读操作的事务，不会失败也不会被等待。区别在于写操作的事务，多版本时间戳机制会回滚“迟到”的写事务，而多版本两阶段加锁通过共享和独占锁来对多个写操作事务排序。同时，我们也讨论了一些多版本并发控制的缺陷。但是，瑕不掩瑜，它依然是最常见的并发控制实现。


## 问题
问题：不使用存储工具，给你两个csv文件，文件user.csv记录用户的消费总额，order.csv记录用户的订单，任何时候，某个用户的消费总额都应该等于order.csv中该用户订单的总和，你怎么实现一个系统来保证读写的事务性。
